## configMap 描述信息

ConfigMap 功能在 Kubernetes1.2 版本中引入，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。ConfigMap API 给我们提供了向容器中注入配置信息的机制，ConfigMap 可以被用来保存单个属性，也可以用来保存整个配置文件或者 JSON 二进制大对象

ConfigMap 的创建

#### 1、使用目录创建

```bash
ls configmap/kubectl/
game.properties
ui.properties

cat configmap/kubectl/game.properties
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30

cat configmap/kubectl/ui.properties
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice

kubectl create configmap game-config --from-file=configmap/kubectl
```

--from-file 指定在目录下的所有文件都会被用在 ConfigMap 里面创建一个键值对，键的名字就是文件名，值就是文件的内容 

#### 2、使用文件创建

只要指定为一个文件就可以从单个文件中创建 ConfigMap

```bash
kubectl create configmap game-config-2 --from-file=configmap/kubectl/game.properties
kubectl get configmaps game-config-2 -o yaml
```

--from-file这个参数可以使用多次，你可以使用两次分别指定上个实例中的那两个配置文件，效果就跟指定整个目录是一样的

#### 3、使用字面值创建

使用文字值创建，利用--from-literal参数传递配置信息，该参数可以使用多次，格式如下

```bash
kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm
kubectl get configmaps special-config -o yaml
```

## Pod 中使用 ConfigMap

#### 1、使用 ConfigMap 来替代环境变量

```yaml 
apiVersion: v1
kind: Config
Mapmetadata:  
  name: special-config  
  namespace: default
data:  
  special.how: very  
  special.type: charm
```

```yaml
apiVersion: v1
kind: ConfigMap
metadata:  
  name: env-config  
  namespace: default
data:  
  log_level: INFO
```

```yaml
apiVersion: v1
kind: Pod
metadata:  
  name: dapi-test-pod
spec:  
  containers:    
    - name: test-container      
      image: wangyanglinux/myapp:v1      
      command: ["/bin/sh","-c","env"]      
      env:        
        - name: SPECIAL_LEVEL_KEY          
          valueFrom:            
            configMapKeyRef:              
              name: special-config              
              key: special.how
        - name: SPECIAL_TYPE_KEY
          valueFrom:            
            configMapKeyRef:              
              name: special-config              
              key: special.type      
      envFrom:        
        - configMapRef:            
            name: env-config  
  restartPolicy: Never
```

#### 2、用 ConfigMap 设置命令行参

```yaml
apiVersion: v1
kind: ConfigMap
metadata:  
  name: special-config  
  namespace: default
data:  
  special.how: very  
  special.type: charm
```

```yaml
apiVersion: v1
kind: Pod
metadata:  
  name: dapi-test-pod01
spec:  
  containers:    
    - name: test-container      
      image: wangyanglinux/myapp:v1      
      command: ["/bin/sh","-c","echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)"]      
      env:        
        - name: SPECIAL_LEVEL_KEY          
          valueFrom:            
            configMapKeyRef:              
              name: special-config              
              key: special.how        
        - name: SPECIAL_TYPE_KEY          
          valueFrom:            
            configMapKeyRef:              
              name: special-config              
              key: special.type  
  restartPolicy: Never
```

#### 3、通过数据卷插件使用ConfigMap

```yaml
apiVersion: v1
kind: ConfigMap
metadata:  
  name: special-config  
  namespace: default
data:  
  special.how: very  
  special.type: charm
```

在数据卷里面使用这个 ConfigMap，有不同的选项。最基本的就是将文件填入数据卷，在这个文件中，键就是文件名，键值就是文件内容

```yaml
apiVersion: v1
kind: Pod
metadata:  
  name: dapi-test-pod111
spec:  
  containers:    
    - name: test-container      
      image: wangyanglinux/myapp:v1       
      command: ["/bin/sh","-c","sleep 600s"]      
      volumeMounts:      
      - name: config-volume        
        mountPath: /etc/config  
  volumes:    
    - name: config-volume      
      configMap:        
        name: special-config  
  restartPolicy: Never
```

## ConfigMap 的热更新

```yaml
apiVersion: v1
kind: ConfigMap
metadata:  
  name: log-config  
  namespace: default
data:  
  log_level: INFO
---
apiVersion: apps/v1
kind: Deployment
metadata:  
  name: my-nginx
spec:  
  replicas: 1 
  selector:    
    matchLabels:      
      run: my-nginx      
  template:
    metadata:      
      labels:        
        run: my-nginx    
    spec:      
      containers:      
      - name: my-nginx        
        image: wangyanglinux/myapp:v1         
        ports:        
        - containerPort: 80        
        volumeMounts:        
        - name: config-volume          
          mountPath: /etc/config      
      volumes:        
        - name: config-volume          
          configMap:            
            name: log-config
```

```bash
kubectl exec `kubectl get pod |grep my-nginx|awk '{print $1}'` -- cat /etc/config/log_level
INFO
```

修改 ConfigMap

```bash
kubectl edit configmap log-config
```

修改log_level的值为DEBUG等待大概 10 秒钟时间，再次查看环境变量的值

```bash
kubectl exec `kubectl get pod |grep my-nginx|awk '{print $1}'` -- cat /etc/config/log_level
DEBUG
```

ConfigMap 更新后滚动更新 Pod

更新 ConfigMap 目前并不会触发相关 Pod 的滚动更新，可以通过修改 pod annotations 的方式强制触发滚动更新

```bash
kubectl patch deployment my-nginx --patch '{"spec": {"template": {"metadata": {"annotations":{"version/config": "20200331" }}}}}'
```

这个例子里我们在.spec.template.metadata.annotations中添加version/config，每次通过修改version/config来触发滚动更新

！！！更新 ConfigMap 后：

- 使用该 ConfigMap 挂载的 Env 不会同步更新
- 使用该 ConfigMap 挂载的 Volume 中的数据需要一段时间（实测大概10秒）才能同步更新